package compiler.syntax;

// Declaracion de importaciones 
//(No modificar las proporcionadas. Se pueden agregar mas)

import java_cup.runtime.Symbol;
import java.util.*;

import es.uned.lsi.compiler.lexical.*;
import es.uned.lsi.compiler.code.*;
import es.uned.lsi.compiler.intermediate.*;
import es.uned.lsi.compiler.semantic.*;
import es.uned.lsi.compiler.semantic.symbol.*;
import es.uned.lsi.compiler.semantic.type.*;
import es.uned.lsi.compiler.syntax.*;

import compiler.CompilerContext;
import compiler.lexical.*;
import compiler.syntax.nonTerminal.*;

import compiler.semantic.symbol.*;
import compiler.semantic.type.*;
import compiler.intermediate.*;
import compiler.code.*;

// Declaracion del codigo de usuario

action code {:
	
	SyntaxErrorManager   syntaxErrorManager   = CompilerContext.getSyntaxErrorManager();
	SemanticErrorManager semanticErrorManager = CompilerContext.getSemanticErrorManager ();
	ScopeManagerIF       scopeManager         = CompilerContext.getScopeManager ();
	FinalCodeFactoryIF   finalCodeFactory     = CompilerContext.getFinalCodeFactory ();

:}	

parser code {:
	SyntaxErrorManager syntaxErrorManager = CompilerContext.getSyntaxErrorManager();
	
	public void syntax_error(Symbol symbol)
	{ 
	    Token token = (Token) symbol.value;
	    syntaxErrorManager.syntaxError ("Error sintactico", token);	    
	}
		
	public void unrecovered_syntax_error(java_cup.runtime.Symbol symbol)
	{	
	    Token token = (Token) symbol.value;
	    syntaxErrorManager.syntaxFatalError ("Error fatal", token);
	}
:}

// Declaracion de terminales (Ejemplo)

terminal Token COMMENT;
//Palabras reservadas
terminal Token BEGIN;
terminal Token BOOLEAN;
terminal Token CONST;
terminal Token ELSE;
terminal Token END;
terminal Token FALSE;
terminal Token FUNCTION;
terminal Token IF;
terminal Token INTEGER;
terminal Token OF;
terminal Token OR;
terminal Token PROCEDURE;
terminal Token PROGRAM;
terminal Token REPEAT;
terminal Token SET;
terminal Token THEN;
terminal Token TRUE;
terminal Token TYPE;
terminal Token UNTIL;
terminal Token VAR;
terminal Token WRITE;
//delimitadores
terminal Token DOUBLE_QUOTE;
terminal Token PARENTHESIS_OPEN;
terminal Token PARENTHESIS_CLOSE;
terminal Token RANGE_OPEN;
terminal Token RANGE_CLOSE;
terminal Token INT_LIST_DELIMITER;
terminal Token VALUE_RANGE_DELIMITER;
terminal Token END_PROGRAM;
terminal Token END_SENTENCE;
terminal Token EQUAL;
terminal Token COLON;
terminal Token ASSIGN_VALUE_VAR_CTE;
//Operadores aritmeticos
terminal Token PLUS;
terminal Token MINUS;
terminal Token MULTI;
//Operadores relacionales
terminal Token GREATER_THAN;
terminal Token NOT_EQUAL;
//Operadores asignación
terminal Token ASSIGN;
//Operadores especiales
terminal Token IN;

//IDENTIFICADORES
terminal Token NUMERO;
terminal Token STRING;
terminal Token IDENTIFICADOR;

// Declaracion de no terminales
// no modificar los propuestos

non terminal  			program;
non terminal Axiom		axiom;
non terminal            programDeclaration;
non terminal            globalDeclaration;
non terminal            globalConstSectionDeclaration;
non terminal            globalTypeSectionDeclaration;
non terminal            globalTypesDeclaration;
non terminal            globalVarSectionDeclaration;
non terminal            globalVarsDeclaration;
non terminal            globalSubProgramSectionDeclaration;
non terminal            globalSubProgramSectionDeclarations;
non terminal            globalSubProgramSectionDeclarationsIntruction;
non terminal            globalProcedureSectionDeclaration;
non terminal            procedureSectionHeaderDeclaration;
non terminal            globalFunctionSectionDeclaration;
non terminal            functionSectionHeaderDeclaration;
non terminal            subProgramBody;
non terminal            procedureArgs;
non terminal            paramIdentificators;
non terminal            paramDeclaration;
non terminal            constDeclarations;
non terminal            constDeclaration;
non terminal            instructionsBlock;
non terminal            instructions;
non terminal            instruction;
non terminal            writeInstruction;
non terminal            assignConjInstruction;
non terminal            aritmeticAssignInstruction;
non terminal            callInstruction;
non terminal            asignCallInstruction;
non terminal            primitiveType;
non terminal            type;
non terminal            aritmeticOp;
non terminal            aritmeticSymbol;
non terminal            conditionalBlock;
non terminal            conditionalExpr;
non terminal            conditionalSentences;
non terminal            conditionalElseSentences;
non terminal            logicalExpr;
non terminal            logicalInConjExpr;
non terminal            logicalOperator;
non terminal            logicalTerm;
non terminal            repeatUntil;
// ...


// Declaracion de relaciones de precedencia
precedence left     MULTI,
                    PLUS,
                    MINUS;

precedence left     OR,
                    NOT_EQUAL,
                    GREATER_THAN;
precedence left     ELSE;
// ...

// Declaraci�n de reglas de produccion


start with program;

program ::= 
  {: 
        syntaxErrorManager.syntaxInfo ("Starting parsing..."); 
   :}
  axiom:ax
  {:   		
  		
  		syntaxErrorManager.syntaxInfo ("Parsing process ended.");
   :};


axiom ::= programDeclaration globalDeclaration BEGIN instructionsBlock END_PROGRAM;
programDeclaration ::= PROGRAM IDENTIFICADOR END_SENTENCE;
globalDeclaration ::= globalConstSectionDeclaration globalTypeSectionDeclaration globalVarSectionDeclaration globalSubProgramSectionDeclaration
                    | globalConstSectionDeclaration globalTypeSectionDeclaration globalVarSectionDeclaration
                    | globalConstSectionDeclaration globalTypeSectionDeclaration globalSubProgramSectionDeclaration
                    | globalConstSectionDeclaration globalVarSectionDeclaration globalSubProgramSectionDeclaration
                    | globalConstSectionDeclaration globalTypeSectionDeclaration
                    | globalConstSectionDeclaration globalVarSectionDeclaration
                    | globalConstSectionDeclaration globalSubProgramSectionDeclaration
                    | globalConstSectionDeclaration
                    | globalTypeSectionDeclaration globalVarSectionDeclaration globalSubProgramSectionDeclaration
                    | globalTypeSectionDeclaration globalVarSectionDeclaration
                    | globalTypeSectionDeclaration globalSubProgramSectionDeclaration
                    | globalTypeSectionDeclaration
                    | globalVarSectionDeclaration globalSubProgramSectionDeclaration
                    | globalVarSectionDeclaration
                    | globalSubProgramSectionDeclaration
                    |;

//GLOBAL CONFIGURATIONS
paramIdentificators ::= paramIdentificators INT_LIST_DELIMITER IDENTIFICADOR | IDENTIFICADOR;
paramDeclaration ::= paramIdentificators COLON type;
//Declaracińo variables
globalVarSectionDeclaration ::= VAR globalVarsDeclaration;
globalVarsDeclaration ::= globalVarsDeclaration paramDeclaration END_SENTENCE |;
//Declaración constantes
globalConstSectionDeclaration ::= CONST | CONST constDeclarations;
constDeclarations ::= constDeclarations constDeclaration | constDeclaration;
constDeclaration ::=  IDENTIFICADOR EQUAL TRUE END_SENTENCE
                    | IDENTIFICADOR EQUAL FALSE END_SENTENCE
                    | IDENTIFICADOR EQUAL STRING END_SENTENCE
                    | IDENTIFICADOR EQUAL NUMERO END_SENTENCE;

globalTypeSectionDeclaration ::= TYPE globalTypesDeclaration;
globalTypesDeclaration ::= globalTypesDeclaration IDENTIFICADOR EQUAL SET OF NUMERO VALUE_RANGE_DELIMITER NUMERO END_SENTENCE |;
//DECLARACION DE SUBPROGRAMA
globalSubProgramSectionDeclaration ::= globalSubProgramSectionDeclarations;
globalSubProgramSectionDeclarations ::= globalSubProgramSectionDeclarations globalSubProgramSectionDeclarationsIntruction
                                        | globalSubProgramSectionDeclarationsIntruction;
globalSubProgramSectionDeclarationsIntruction ::= globalFunctionSectionDeclaration | globalProcedureSectionDeclaration;
//  - DECLARACION DE PROCEDURE
subProgramBody ::= BEGIN instructionsBlock END END_SENTENCE;
globalProcedureSectionDeclaration ::= procedureSectionHeaderDeclaration subProgramBody
                                      | procedureSectionHeaderDeclaration globalVarSectionDeclaration subProgramBody;
procedureSectionHeaderDeclaration ::= PROCEDURE IDENTIFICADOR PARENTHESIS_OPEN procedureArgs PARENTHESIS_CLOSE END_SENTENCE;
procedureArgs ::= paramDeclaration;
//  - DECLARACION DE FUNCTION
globalFunctionSectionDeclaration ::= functionSectionHeaderDeclaration subProgramBody
                                     | functionSectionHeaderDeclaration globalVarSectionDeclaration subProgramBody;
functionSectionHeaderDeclaration ::= FUNCTION IDENTIFICADOR PARENTHESIS_OPEN procedureArgs PARENTHESIS_CLOSE COLON primitiveType END_SENTENCE;

// var types
primitiveType ::= INTEGER | BOOLEAN;
type ::= primitiveType | IDENTIFICADOR;
// INSTRUCTION BLOCK
instructionsBlock ::= | instructions;
instructions ::= instructions instruction
                | instruction;
instruction ::=   writeInstruction
                | callInstruction
                | assignConjInstruction
                | aritmeticAssignInstruction
                | conditionalBlock
                | repeatUntil;

//WRITE INSTRUCTION
writeInstruction ::= WRITE PARENTHESIS_OPEN STRING PARENTHESIS_CLOSE END_SENTENCE
 | WRITE PARENTHESIS_OPEN IDENTIFICADOR PARENTHESIS_CLOSE END_SENTENCE;

//Instruccion de llamada a función o procedure
callInstruction ::= IDENTIFICADOR ASSIGN IDENTIFICADOR PARENTHESIS_OPEN IDENTIFICADOR PARENTHESIS_CLOSE END_SENTENCE
                    | IDENTIFICADOR PARENTHESIS_OPEN IDENTIFICADOR PARENTHESIS_CLOSE END_SENTENCE;

//INSTRUCCION DE ASIGNACIÓN
assignConjInstruction ::=  IDENTIFICADOR ASSIGN RANGE_OPEN NUMERO VALUE_RANGE_DELIMITER NUMERO RANGE_CLOSE END_SENTENCE
                         | IDENTIFICADOR ASSIGN RANGE_OPEN RANGE_CLOSE END_SENTENCE;

//INSTRUCCIONES ARITMETICAS
aritmeticAssignInstruction ::= IDENTIFICADOR ASSIGN aritmeticOp END_SENTENCE;
aritmeticOp ::= aritmeticOp aritmeticSymbol aritmeticOp
                | PARENTHESIS_OPEN aritmeticOp PARENTHESIS_CLOSE
                | NUMERO
                | IDENTIFICADOR;
aritmeticSymbol ::= PLUS | MINUS | MULTI;
//CONDICIONAL
conditionalBlock ::=   conditionalExpr conditionalSentences;
conditionalExpr ::= IF PARENTHESIS_OPEN logicalExpr PARENTHESIS_CLOSE THEN;
conditionalSentences ::= instruction conditionalElseSentences;
conditionalElseSentences ::= ELSE instruction |;
//EXPRESION BOOLEANA
logicalInConjExpr ::= NUMERO IN IDENTIFICADOR;
logicalExpr ::=   logicalTerm
                | logicalExpr logicalOperator logicalExpr
                | logicalInConjExpr;
logicalOperator ::= GREATER_THAN | NOT_EQUAL | OR;
logicalTerm ::= TRUE
                | FALSE
                | STRING
                | NUMERO
                | IDENTIFICADOR
                | PARENTHESIS_OPEN logicalExpr PARENTHESIS_CLOSE;

 //BUCLES
 //   - rpeat until
 repeatUntil ::= REPEAT instructionsBlock UNTIL PARENTHESIS_OPEN logicalExpr PARENTHESIS_CLOSE END_SENTENCE;